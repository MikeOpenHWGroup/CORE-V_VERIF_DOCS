

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Simulation Tests in the UVM Environments &mdash; CORE-V Verification Strategy  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="CORE-V Formal Verification" href="formal.html" />
    <link rel="prev" title="CV64A Simulation Testbench and Environment" href="cv64_env.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #DDDDDD" >
          

          
            <a href="index.html" class="icon icon-home"> CORE-V Verification Strategy
          

          
            
            <img src="_static/openhw-landscape.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="planning_requirements.html">Verification Planning and Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulp_verif.html">PULP-Platform Simulation Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="cv32_env.html">CV32E40P Simulation Testbench and Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="cv64_env.html">CV64A Simulation Testbench and Environment</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Simulation Tests in the UVM Environments</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#test-program">Test Program</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#virtual-peripherals">Virtual Peripherals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#uvm-test">UVM Test</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#workarounds">Workarounds</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#run-flow-in-a-core-v-test">Run-flow in a CORE-V Test</a></li>
<li class="toctree-l2"><a class="reference internal" href="#core-v-testcase-writers-guide">CORE-V Testcase Writer’s Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#file-structure-of-the-test-programs-and-uvm-tests">File Structure of the Test Programs and UVM Tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-a-test-program">Writing a Test Program</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-a-uvm-test-to-run-a-test-program">Writing a UVM Test to run a Test Program</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#testcase-scriptware">Testcase Scriptware</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#running-the-testcase">Running the testcase</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="formal.html">CORE-V Formal Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="fpga.html">CORE-V FPGA Prototyping</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CORE-V Verification Strategy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Simulation Tests in the UVM Environments</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/sim_tests.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="simulation-tests-in-the-uvm-environments">
<span id="sim-tests"></span><h1>Simulation Tests in the UVM Environments<a class="headerlink" href="#simulation-tests-in-the-uvm-environments" title="Permalink to this headline">¶</a></h1>
<p>With the exception of the “core testbench” for CV32E40P, the CORE-V
environments are all UVM environments and the overall structure should
be familiar to anyone with UVM experience. This section discusses the
CORE-V-specific implementation details that affect test execution, and
that are important to test writers. It attempts to be generic enough to
apply to both the CV32E and CV64A environments.</p>
<p>A unique feature of the CORE-V UVM environments is that a primary source
of stimulus, and sometimes the only source of stimulus, comes in the
form of a “test program” that is loaded into the testbench’s memory
model and then executed by the core itself. The UVM test, environment
and agents are often secondary sources of stimulus and sometimes do not
provide any stimulus at all. This means it is important to draw a
distinction between the “<strong>test program</strong>” which is a set of
instructions executed by the core, and the “<strong>UVM test</strong>”, which is
a testcase in the UVM sense of the word.</p>
<div class="section" id="test-program">
<span id="id1"></span><h2>Test Program<a class="headerlink" href="#test-program" title="Permalink to this headline">¶</a></h2>
<p>In this context a “test program” is set of RISC-V instructions that are
loaded into the testbench memory. The core will starting fetching and
executing these instructions when <em>fetch_en</em> is asserted. Test programs
may be manually produced by a human or by a tool such as the UVM random
instructor generator component of the environment. Test programs are
coded either in RISC-V assembler or C. All of the randomly generated
programs are RISC-V assembler <a class="footnote-reference" href="#id8" id="id2">[11]</a>.</p>
<p>The environment can support test programs regardless of how they are
created. However, the environment needs to know two things about a test
program:</p>
<ul class="simple">
<li>Is the program pre-existing, or does it need to be generated at
run-time?</li>
<li>Is the test program self-checking? That is, can it determine, on its
own, the pass/fail criteria of a test program and can it signal this
to the testbench?</li>
</ul>
<p>Section <a class="reference internal" href="pulp_verif.html#ri5cy-testcases"><span class="std std-ref">RI5CY Testcases</span></a> details how many of the test programs
inherited from the RI5CY project are both pre-existing and
self-checking. It is expected, but not required, that most of the
pre-existing test programs will be self-checking.</p>
<p>Section ToDo introduces the operation of the random instruction
generator and how it generates test programs. Here, the situation
regarding to self-checking tests is inverted. That is, it is expected,
but not required, that most of the generated test programs will <strong>not</strong>
be self-checking.</p>
<p>The UVM environment is equipped to support four distinct types of test
programs:</p>
<ol class="arabic simple">
<li><strong>Pre-existing, self-checking</strong>
The environment requires a memory image for the program to exist in
the expected location, and will check the “status flags <a class="footnote-reference" href="#id9" id="id3">[12]</a>”
virtual peripheral for pass/fail information.</li>
<li><strong>Pre-existing, not self-checking</strong>
The environment requires a memory image for the program to exist in
the expected location, and will <strong>not</strong> check the “status flags”
virtual peripheral for pass/fail information.</li>
<li><strong>Generated, self-checking</strong>
The environment will use its random instruction generator to create a
test program, and will check the “status flags” virtual peripheral
for pass/fail information.</li>
<li><strong>Generated, not self-checking</strong>
The environment will use its random instruction generator to create a
test program, and will <strong>not</strong> check the “status flags” virtual
peripheral for pass/fail information.</li>
<li><strong>None</strong>
It is possible to run a UVM test without running a test program. An
example might be a test to access CSRs via the debug module interface
interface in debug mode.</li>
</ol>
<p>Although five types are supported, it is expected that types 1 and 4
will predominate.</p>
<p>Simulations pass/fail outcomes will also be affected by other
checkers/monitors that are not part of the status flags virtual
peripheral. It is required that any such checkers/monitors shall signal
an error condition with `uvm_error(), and these will cause a
simulation test to fail, independent of what the test program may or may
not write to the status flags virtual peripheral.</p>
<p>It is possible to use an instruction generator to write out a set of
test programs, self checking or not, and run these as if they were
pre-existing test programs. From the environment’s perspective, this
indistinguishable from type 1 or type 2.</p>
<p>The programs can be written to execute any legal instruction supported
by the core <a class="footnote-reference" href="#id10" id="id4">[13]</a>. Programs have access to the full address range
supported by the memory model in the testbench plus a small set of
memory-mapped “virtual peripherals”, see below.</p>
<div class="section" id="virtual-peripherals">
<span id="id5"></span><h3>Virtual Peripherals<a class="headerlink" href="#virtual-peripherals" title="Permalink to this headline">¶</a></h3>
<p>A SystemVerilog module called <em>mm_ram</em> is located at
<em>$PROJ_ROOT/cv32/tb/core/mm_ram.sv</em>. It connects to the core as shown
in . In additional to supporting the instruction and data memory
(<em>dp_ram</em>) this module implements a set of virtual peripherals by
responding to write cycles at specific addresses on the data bus. These
virtual peripherals provides the features listed in .</p>
<p>The printer and status flags virtual peripherals are used in almost
every assembler testcase provided by the RISC-V foundation for their ISA
compliance test-suite. As such, these virtual peripherals will be
maintained throughout the entire CORE-V verification effort. It is also
believed, but not known for certain, that the signature writer is used
by several existing testcases, so this peripheral may also be maintained
over the long term.</p>
<p>The use of the interrupt timer control and instruction memory stall
controller are not well understood and it is possible that none of the
testscases inherited from the RISC-V foundation or the PULP-Platform
team use them. As such they are likely to be deprecated and their use by
new test programs developed for CORE-V is strongly discouraged.</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="20%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Virtual Peripheral</th>
<th class="head">VP Address
(data_addr_i)</th>
<th class="head">Action on Write</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Address Range Check</td>
<td>&gt;= 2**16, but not one</td>
<td>Terminate simulation
TODO: make this a `uvm_fatal()</td>
</tr>
<tr class="row-odd"><td>Virtual Printer</td>
<td>32’h1000_0000</td>
<td>$write(“%c”, wdata[7:0]);</td>
</tr>
<tr class="row-even"><td rowspan="2">Interrupt Timer Control</td>
<td>32’h1500_0000</td>
<td>timer_irg_mask &lt;= wdata;</td>
</tr>
<tr class="row-odd"><td>32’h1500_0004</td>
<td><p class="first">timer_count &lt;= wdata;</p>
<p>This starts a timer that counts down each clk cycle.</p>
<p class="last">When timer hits 0, an interrupt (irq_o) is asserted.</p>
</td>
</tr>
<tr class="row-even"><td rowspan="2">Virtual Peripheral
Status Flags</td>
<td>32’h2000_0000</td>
<td><p class="first">Assert test_passed if wdata==’d123456789</p>
<p>Assert test_failed if wdata==’d1</p>
<p class="last"><strong>Note</strong>: asserted for one clk cycle only.</p>
</td>
</tr>
<tr class="row-odd"><td>32’h2000_0004</td>
<td><p class="first">Assert exit_valid;</p>
<p>exit_value &lt;= wdata;</p>
<p class="last"><strong>Note</strong>: asserted for one clk cycle only.</p>
</td>
</tr>
<tr class="row-even"><td rowspan="3">Signature Writer</td>
<td>32’h2000_0008</td>
<td>signature_start_address &lt;= wdata;</td>
</tr>
<tr class="row-odd"><td>32’h2000_000C</td>
<td>signature_end_address &lt;= wdata;</td>
</tr>
<tr class="row-even"><td>32’h2000_0010</td>
<td><p class="first">Write contents of dp_ram from sig_start_addr to sig_end_addr
to the signature file.</p>
<p>Signature filename must be provided at run-time using a</p>
<p>+signature=&lt;sig_file&gt; plusarg.</p>
<p class="last">Note: this will also asset exit_valid with exit_value &lt;= 0.</p>
</td>
</tr>
<tr class="row-odd"><td rowspan="2">Instruction Memory
Interface Stall Control</td>
<td rowspan="2">32’h1600_XXXX</td>
<td rowspan="2">Program a table that introduces “random” stalls on IMEM I/F.</td>
</tr>
<tr class="row-even"></tr>
</tbody>
</table>
<p>Table 1: List of Virtual Peripherals</p>
</div>
</div>
<div class="section" id="uvm-test">
<span id="id6"></span><h2>UVM Test<a class="headerlink" href="#uvm-test" title="Permalink to this headline">¶</a></h2>
<p>A UVM Test is the top-level object in every UVM environment. That is,
the environment object(s) are members of the testcase object, not the
other way around. As such, UVM requires that all tests extend from
<em>uvm_test</em> and the CV32E environment defines a “base test”,
<em>uvmt_cv32_base_test_c</em>, that is a direct extension of <em>uvm_test</em>.
All testcases developed for CV32E should extend from the base test, as
doing so ensures that the proper test flow discussed here is maintained
(it also frees the test writer from much mundane effort and code
duplication). The comment headers in the base test (attempt to) provide
sufficient information for the test writer to understand how to extend
it for their needs.</p>
<p>A typical UVM test for CORE-V will extend three time consuming tasks:</p>
<ol class="arabic simple">
<li><strong>reset_phase():</strong> often, nothing is done here except to call
<em>super.reset_phase()</em> which will invoke the default reset sequence
(which is a random sequence). Should the test writer wish to, this is
where a test-specific reset virtual sequence could be invoked.</li>
<li><strong>configure_phase():</strong> in a typical UVM environment, this is a busy
task. However, assuming the program executed the core does so, the
core’s CSRs do not require any configuration before execution begins.
Any test that requires pre-compiled programs to be loaded into
instruction memory should do that here.</li>
<li><strong>run_phase():</strong> for most tests, this is where the procedural code
for the test will reside. A typical example of the run-flow here
would be:
-  Raise an objection;
-  Assert the core’s fetch_en input;
-  Wait for the core and/or environment(s) to signal completion;
-  Drop the objection.</li>
</ol>
<div class="section" id="workarounds">
<h3>Workarounds<a class="headerlink" href="#workarounds" title="Permalink to this headline">¶</a></h3>
<p>The CV32E base test, <em>uvmt_cv32_base_test_c</em>, in-lines code (using
<strong>`include)</strong> from <em>uvmt_cv32_base_test_workaround.sv</em>. This file
is a convenient place to put workarounds for defects or incomplete code
in either the environment or RTL that will affect all tests. This file
must be reviewed before the RTL is frozen, and ideally it will be empty
at that time.</p>
</div>
</div>
<div class="section" id="run-flow-in-a-core-v-test">
<h2>Run-flow in a CORE-V Test<a class="headerlink" href="#run-flow-in-a-core-v-test" title="Permalink to this headline">¶</a></h2>
<p>The test program in the CORE-V environment directly impacts the usual
run-flow that is familiar to UVM developers. Programs running on the
core are completely self-contained within their extremely simple
execution environment that is wholly defined by the ISA, memory map
supported by the <em>dp_mem</em> and the virtual peripherals supported by
<em>mm_mem</em> <a class="footnote-reference" href="#id11" id="id7">[14]</a>. This execution environment knows nothing about the
UVM environment, so the CORE-V UVM environments are implemented to be
aware of the test program and to respond accordingly as part of the
run-flow.</p>
<p>Section <a class="reference internal" href="#test-program"><span class="std std-ref">Test Program</span></a> introduced the five types of core test
programs supported by the CORE UVM environment and section
<a class="reference internal" href="#uvm-test"><span class="std std-ref">UVM Test</span></a> showed how the configure_phase() and run_phase()
of a CORE-V UVM run-flow implement the interaction between the UVM
environment and the test program. This interaction is depends on the
type of test program. Illustration 6 shows how the CORE-V UVM base test
supports a type 1 test program.</p>
<div class="figure align-center" id="type1-test-program">
<img alt="" src="_images/type1.png" />
<p class="caption"><span class="caption-text">Illustration 6: Preexisting, Self-checking Test Program (type 1) in a
CORE-V UVM test</span></p>
</div>
<p>In the self-checking scenario, the testcase is pre-compiled into machine
code and loaded into the <em>dp_ram</em> using the <strong>$readmemh()</strong> DPI call.
The next sub-section explains how to select which test program to run
from the command-line. During the configuration phase the test signals
the TB to load the memory. The TB assumes the test file already exists
and will terminate the simulation if it does not.</p>
<p>In the run phase the base test will assert the fetch_en input to the
core which signals it to start running. The timing of this is randomized
but keep in mind that it will always happen after reset is de-asserted
(because resets are done in the reset phase, which always executes
before the run phase).</p>
<p>At this point the run flow will simply wait for the test program to flag
that it is done via the status flags virtual peripheral. The test
program is also expected to properly assert the test pass or test fail
flags. Note that the environment will wait for the test flags to asserts
or until the environment’s watch dog timer fires. A watch-dog firing
will terminate the simulation and is, by definition, a failure.</p>
<div class="figure align-center" id="type4-test-program">
<img alt="" src="_images/type4.png" />
<p class="caption"><span class="caption-text">Illustration 7: Generated, non-self-checking (type 4) Test Program in
a CORE-V UVM test</span></p>
</div>
<p>The flow for a type 4 (generated, non-self checking) test program is
only slightly different as shown in Illustration 7. In these tests the configure phase
will invoke the generator to produce a test program and the toolchain to
compile it before signalling the TB to load the machine code into
<em>dp_mem</em>. As before, the run phase will assert fetch_en to the core
and the program begins execution.</p>
<p>Recall that a type 4 test program will not use the status flags virtual
peripheral to signal test completion. It is therefore up to the UVM
environment to detect end of test. This is done when the various agents
in the environment detect a lack of activity on their respective
interfaces. The primary way to detect this is via the Instruction-Retire
agent (TODO: describe this agent).</p>
<p>In a non-self-checking test program the intelligence to determine
pass/fail must come from the environment. In the CORE-V UVM environments
this is done by scoreboarding the results of the core execution and
those predicted by the ISS as shown in . Note that most UVM tests that
run self-checking test programs will also use the ISS as part of its
pass/fail determination.</p>
</div>
<div class="section" id="core-v-testcase-writers-guide">
<h2>CORE-V Testcase Writer’s Guide<a class="headerlink" href="#core-v-testcase-writers-guide" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
<div class="section" id="file-structure-of-the-test-programs-and-uvm-tests">
<h3>File Structure of the Test Programs and UVM Tests<a class="headerlink" href="#file-structure-of-the-test-programs-and-uvm-tests" title="Permalink to this headline">¶</a></h3>
<p>Below is a somewhat simplified view of the CV32 tests directory tree.
The test programs are in cv32/tests/core. (This should probably be
cv32/tests/programs, but is named “core” for historical reasons.)
Sub-directories below core contain a number of type 1 test programs.</p>
<p>The UVM tests are located at cv32/tests/uvmt_cv32. It is a very good
idea to review the code in the base-tests sub-directory. In
“core-program-tests” is the type 1 and type 4 testcases (types 2 and 3
may be added at a later date). These ca be used as examples and are also
production level tests for either type 1 or type 4 test programs. An up
to date description of the testcases under uvmt_cv32 can be found in
the associated README.</p>
<p>Lastly, the cv32/tests/vseq directory is where you will be (and should
add) virtual sequences for any new testcases you develop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$PROJ\_ROOT/
└── cv32/
     └── tests/
           ├── core/
           │    ├── README.md
           │    ├── custom/
           │    │ ├── hello_world.c
           │    │ └── &lt;etc&gt;
           │    ├── riscv_compliance_tests_firmware/
           │    │ ├── addi.S
           │    │ └── &lt;etc&gt;
           │    ├── riscv_tests_firmware/
           │    │ └── &lt;etc&gt;
           │    └── firmware/
           │    └── &lt;etc&gt;
           └── uvmt_cv32/
                 ├── base-tests/
                 │    ├── uvmt_cv32_base_test.sv
                 │    ├── uvmt_cv32_base_test_workarounds.sv
                 │    └── uvmt_cv32_test_cfg.sv
                 ├── core-program-tests/
                 │    ├── README.md
                 │    └── uvmt_cv32_type1_test.sv
                 │    └── uvmt_cv32_type4_test.sv
                 └── vseq/
                      └── uvmt_cv32_vseq_lib.sv
</pre></div>
</div>
</div>
<div class="section" id="writing-a-test-program">
<h3>Writing a Test Program<a class="headerlink" href="#writing-a-test-program" title="Permalink to this headline">¶</a></h3>
<p>This document will probably never include a detailed description for
writing a test program. The core’s ISA is well documented and the
execution environment supported by the testbench is trivial. The best
thing to do is check out the examples at
<strong>$PROJ_ROOT/cv32/tests/core</strong>.</p>
</div>
<div class="section" id="writing-a-uvm-test-to-run-a-test-program">
<h3>Writing a UVM Test to run a Test Program<a class="headerlink" href="#writing-a-uvm-test-to-run-a-test-program" title="Permalink to this headline">¶</a></h3>
<p>The CV32 base test, <em>uvmt_cv32_base_test_c</em>, has been written to
support all five of the test program types discussed in Section
<a class="reference internal" href="#test-program"><span class="std std-ref">Test Program</span></a>.</p>
<p>There are pre-existing UVM tests for type 1 (pre-existing,
self-checking) and type 4 (generated, not-self-checking) tests for
CV32E40P in the core-v-verif repository. If you need a type 2 or type 3
test, have a look at these and it should be obvious what to do.</p>
<div class="section" id="testcase-scriptware">
<h4>Testcase Scriptware<a class="headerlink" href="#testcase-scriptware" title="Permalink to this headline">¶</a></h4>
<p>At <strong>$PROJ_ROOT/cv32/tests/uvmt_cv32/bin/test_template</strong> you will
find a shell script that will generate the shell of a testcase that is
compatible with the base test. This will save you a bit of typing.</p>
</div>
</div>
<div class="section" id="running-the-testcase">
<h3>Running the testcase<a class="headerlink" href="#running-the-testcase" title="Permalink to this headline">¶</a></h3>
<p>Testcases are intended to be launched from
<strong>$PROJ_ROOT/cv32/sim/uvmt_cv32</strong>. The README at this location is
intended to provide you with everything you need to know to run an
existing testcase or a new testcase. If this is not the case, please
create a GitHub issue and assign it to &#64;mikeopenhwgroup.</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[11]</a></td><td>Those familiar with the RI5CY testbench may recall that random
generation of C programs using
<a class="reference external" href="https://embed.cs.utah.edu/csmith/">csmith</a> was supported. Csmith
was developed to exercise C compilers, not processors, it is not
supported in the CORE-V environments.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[12]</a></td><td>See Section <a class="reference internal" href="#virtual-peripherals"><span class="std std-ref">Virtual Peripherals</span></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[13]</a></td><td>Generation of illegal or malformed instructions is also supported,
and will be discussed in a later version of this document.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[14]</a></td><td>This is termed Execution Environment Interface or EEI by the RISC-V
ISA.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="formal.html" class="btn btn-neutral float-right" title="CORE-V Formal Verification" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cv64_env.html" class="btn btn-neutral float-left" title="CV64A Simulation Testbench and Environment" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, OpenHW Group

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>